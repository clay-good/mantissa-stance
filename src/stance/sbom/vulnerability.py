"""
Vulnerability database and scanning for SBOM.

Provides vulnerability lookup, CVE matching, and security assessment
for software dependencies using NVD and OSV databases.
"""

from __future__ import annotations

import hashlib
import json
import logging
import re
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any
from urllib.parse import quote

from stance.sbom.parser import Dependency, DependencyFile, PackageEcosystem

logger = logging.getLogger(__name__)


class VulnerabilitySeverity(Enum):
    """Vulnerability severity levels (CVSS-based)."""

    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"  # CVSS 7.0-8.9
    MEDIUM = "medium"  # CVSS 4.0-6.9
    LOW = "low"  # CVSS 0.1-3.9
    NONE = "none"  # CVSS 0.0
    UNKNOWN = "unknown"


class VulnerabilitySource(Enum):
    """Source of vulnerability information."""

    NVD = "nvd"  # NIST National Vulnerability Database
    OSV = "osv"  # Open Source Vulnerabilities
    GHSA = "ghsa"  # GitHub Security Advisories
    SNYK = "snyk"  # Snyk vulnerability database
    MANUAL = "manual"  # Manually added
    LOCAL = "local"  # Local database


@dataclass
class VulnerabilityReference:
    """External reference for a vulnerability."""

    url: str
    source: str
    tags: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "url": self.url,
            "source": self.source,
            "tags": self.tags,
        }


@dataclass
class AffectedVersion:
    """Version range affected by a vulnerability."""

    introduced: str | None = None  # Version where vulnerability was introduced
    fixed: str | None = None  # Version where vulnerability was fixed
    last_affected: str | None = None  # Last affected version
    version_type: str = "semver"  # semver, git, etc.

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "introduced": self.introduced,
            "fixed": self.fixed,
            "last_affected": self.last_affected,
            "version_type": self.version_type,
        }

    def is_version_affected(self, version: str) -> bool:
        """Check if a specific version is affected."""
        try:
            from packaging import version as pkg_version

            v = pkg_version.parse(version)

            if self.introduced:
                introduced_v = pkg_version.parse(self.introduced)
                if v < introduced_v:
                    return False

            if self.fixed:
                fixed_v = pkg_version.parse(self.fixed)
                if v >= fixed_v:
                    return False

            if self.last_affected:
                last_v = pkg_version.parse(self.last_affected)
                if v > last_v:
                    return False

            return True
        except Exception:
            # Fall back to simple string comparison
            if self.fixed and version == self.fixed:
                return False
            return True


@dataclass
class Vulnerability:
    """Represents a security vulnerability."""

    # Identification
    id: str  # CVE-XXXX-XXXX, GHSA-xxxx-xxxx, etc.
    aliases: list[str] = field(default_factory=list)  # Alternative IDs

    # Description
    summary: str = ""
    description: str = ""

    # Severity
    severity: VulnerabilitySeverity = VulnerabilitySeverity.UNKNOWN
    cvss_score: float | None = None
    cvss_vector: str | None = None

    # Source
    source: VulnerabilitySource = VulnerabilitySource.NVD

    # Affected packages
    affected_ecosystem: PackageEcosystem = PackageEcosystem.UNKNOWN
    affected_package: str = ""
    affected_versions: list[AffectedVersion] = field(default_factory=list)

    # Fix information
    fixed_versions: list[str] = field(default_factory=list)
    patch_available: bool = False

    # Metadata
    published: datetime | None = None
    modified: datetime | None = None
    withdrawn: datetime | None = None

    # References
    references: list[VulnerabilityReference] = field(default_factory=list)

    # CWE information
    cwes: list[str] = field(default_factory=list)  # CWE-XXX IDs

    # Additional data
    credits: list[str] = field(default_factory=list)
    database_specific: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "aliases": self.aliases,
            "summary": self.summary,
            "description": self.description,
            "severity": self.severity.value,
            "cvss_score": self.cvss_score,
            "cvss_vector": self.cvss_vector,
            "source": self.source.value,
            "affected": {
                "ecosystem": self.affected_ecosystem.value,
                "package": self.affected_package,
                "versions": [v.to_dict() for v in self.affected_versions],
            },
            "fixed_versions": self.fixed_versions,
            "patch_available": self.patch_available,
            "published": self.published.isoformat() if self.published else None,
            "modified": self.modified.isoformat() if self.modified else None,
            "withdrawn": self.withdrawn.isoformat() if self.withdrawn else None,
            "references": [r.to_dict() for r in self.references],
            "cwes": self.cwes,
            "credits": self.credits,
        }

    def is_version_affected(self, version: str) -> bool:
        """Check if a specific version is affected."""
        if not self.affected_versions:
            # No version constraints, assume all versions affected
            return True

        for av in self.affected_versions:
            if av.is_version_affected(version):
                return True

        return False


@dataclass
class VulnerabilityMatch:
    """Represents a vulnerability match for a dependency."""

    dependency: Dependency
    vulnerability: Vulnerability
    match_confidence: float = 1.0  # 0.0 to 1.0

    @property
    def severity(self) -> VulnerabilitySeverity:
        """Get the severity of the matched vulnerability."""
        return self.vulnerability.severity

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "dependency": {
                "name": self.dependency.name,
                "version": self.dependency.version,
                "ecosystem": self.dependency.ecosystem.value,
            },
            "vulnerability": self.vulnerability.to_dict(),
            "match_confidence": self.match_confidence,
        }


@dataclass
class VulnerabilityScanResult:
    """Result of vulnerability scanning."""

    # Summary
    total_dependencies: int = 0
    vulnerable_dependencies: int = 0
    total_vulnerabilities: int = 0

    # Severity breakdown
    critical_count: int = 0
    high_count: int = 0
    medium_count: int = 0
    low_count: int = 0
    unknown_count: int = 0

    # Matches
    matches: list[VulnerabilityMatch] = field(default_factory=list)

    # Scan metadata
    scan_timestamp: datetime = field(default_factory=datetime.utcnow)
    sources_used: list[str] = field(default_factory=list)
    scan_duration_ms: int = 0

    @property
    def has_vulnerabilities(self) -> bool:
        """Check if any vulnerabilities were found."""
        return self.total_vulnerabilities > 0

    @property
    def highest_severity(self) -> VulnerabilitySeverity:
        """Get the highest severity found."""
        if self.critical_count > 0:
            return VulnerabilitySeverity.CRITICAL
        if self.high_count > 0:
            return VulnerabilitySeverity.HIGH
        if self.medium_count > 0:
            return VulnerabilitySeverity.MEDIUM
        if self.low_count > 0:
            return VulnerabilitySeverity.LOW
        return VulnerabilitySeverity.NONE

    def get_critical_matches(self) -> list[VulnerabilityMatch]:
        """Get vulnerabilities with critical severity."""
        return [m for m in self.matches if m.severity == VulnerabilitySeverity.CRITICAL]

    def get_high_matches(self) -> list[VulnerabilityMatch]:
        """Get vulnerabilities with high severity."""
        return [m for m in self.matches if m.severity == VulnerabilitySeverity.HIGH]

    def group_by_dependency(self) -> dict[str, list[VulnerabilityMatch]]:
        """Group matches by dependency name."""
        result: dict[str, list[VulnerabilityMatch]] = {}
        for match in self.matches:
            key = f"{match.dependency.name}@{match.dependency.version}"
            if key not in result:
                result[key] = []
            result[key].append(match)
        return result

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "summary": {
                "total_dependencies": self.total_dependencies,
                "vulnerable_dependencies": self.vulnerable_dependencies,
                "total_vulnerabilities": self.total_vulnerabilities,
                "has_vulnerabilities": self.has_vulnerabilities,
                "highest_severity": self.highest_severity.value,
            },
            "severity_breakdown": {
                "critical": self.critical_count,
                "high": self.high_count,
                "medium": self.medium_count,
                "low": self.low_count,
                "unknown": self.unknown_count,
            },
            "matches": [m.to_dict() for m in self.matches],
            "metadata": {
                "scan_timestamp": self.scan_timestamp.isoformat(),
                "sources_used": self.sources_used,
                "scan_duration_ms": self.scan_duration_ms,
            },
        }


class VulnerabilityDatabase:
    """
    Local vulnerability database with NVD/OSV integration.

    Provides vulnerability lookup and matching for dependencies.
    Supports both online queries and offline local database.
    """

    # Ecosystem to OSV ecosystem mapping
    ECOSYSTEM_MAP = {
        PackageEcosystem.NPM: "npm",
        PackageEcosystem.PYPI: "PyPI",
        PackageEcosystem.GO: "Go",
        PackageEcosystem.CARGO: "crates.io",
        PackageEcosystem.MAVEN: "Maven",
        PackageEcosystem.NUGET: "NuGet",
        PackageEcosystem.RUBYGEMS: "RubyGems",
        PackageEcosystem.COMPOSER: "Packagist",
    }

    def __init__(
        self,
        cache_dir: str | Path | None = None,
        offline_mode: bool = False,
    ):
        """
        Initialize the vulnerability database.

        Args:
            cache_dir: Directory to store cached vulnerability data
            offline_mode: Only use local cache, don't query online sources
        """
        self._cache_dir = Path(cache_dir) if cache_dir else Path.home() / ".stance" / "vuln_cache"
        self._offline_mode = offline_mode
        self._local_db: dict[str, list[Vulnerability]] = {}

        # Ensure cache directory exists
        self._cache_dir.mkdir(parents=True, exist_ok=True)

    def query_osv(
        self,
        package: str,
        version: str,
        ecosystem: PackageEcosystem,
    ) -> list[Vulnerability]:
        """
        Query OSV (Open Source Vulnerabilities) database.

        Args:
            package: Package name
            version: Package version
            ecosystem: Package ecosystem

        Returns:
            List of matching vulnerabilities
        """
        if self._offline_mode:
            return self._query_local_cache(package, ecosystem)

        osv_ecosystem = self.ECOSYSTEM_MAP.get(ecosystem)
        if not osv_ecosystem:
            logger.debug(f"Unsupported ecosystem for OSV: {ecosystem}")
            return []

        try:
            import urllib.request
            import urllib.error

            url = "https://api.osv.dev/v1/query"
            data = json.dumps({
                "package": {
                    "name": package,
                    "ecosystem": osv_ecosystem,
                },
                "version": version,
            }).encode("utf-8")

            req = urllib.request.Request(
                url,
                data=data,
                headers={"Content-Type": "application/json"},
                method="POST",
            )

            with urllib.request.urlopen(req, timeout=30) as response:
                result = json.loads(response.read().decode("utf-8"))

            vulnerabilities = []
            for vuln_data in result.get("vulns", []):
                vuln = self._parse_osv_vulnerability(vuln_data, ecosystem, package)
                if vuln:
                    vulnerabilities.append(vuln)
                    self._cache_vulnerability(vuln)

            return vulnerabilities

        except urllib.error.HTTPError as e:
            logger.warning(f"OSV query failed for {package}: HTTP {e.code}")
            return self._query_local_cache(package, ecosystem)
        except urllib.error.URLError as e:
            logger.warning(f"OSV query failed for {package}: {e.reason}")
            return self._query_local_cache(package, ecosystem)
        except Exception as e:
            logger.exception(f"OSV query failed for {package}")
            return self._query_local_cache(package, ecosystem)

    def query_nvd(
        self,
        package: str,
        version: str,
        ecosystem: PackageEcosystem,
    ) -> list[Vulnerability]:
        """
        Query NVD (National Vulnerability Database).

        Note: NVD requires API key for reliable access. Without a key,
        rate limiting is severe. This implementation uses CPE matching.

        Args:
            package: Package name
            version: Package version
            ecosystem: Package ecosystem

        Returns:
            List of matching vulnerabilities
        """
        if self._offline_mode:
            return self._query_local_cache(package, ecosystem)

        # NVD requires CPE string for accurate queries
        # Building CPE: cpe:2.3:a:vendor:product:version:*:*:*:*:*:*:*
        # For now, we'll use keyword search which is less accurate

        try:
            import urllib.request
            import urllib.error

            # URL encode the package name for keyword search
            keyword = quote(package)
            url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?keywordSearch={keyword}"

            req = urllib.request.Request(
                url,
                headers={
                    "User-Agent": "Mantissa-Stance/1.0",
                },
            )

            with urllib.request.urlopen(req, timeout=30) as response:
                result = json.loads(response.read().decode("utf-8"))

            vulnerabilities = []
            for item in result.get("vulnerabilities", []):
                cve_data = item.get("cve", {})
                vuln = self._parse_nvd_vulnerability(cve_data, ecosystem, package, version)
                if vuln:
                    vulnerabilities.append(vuln)
                    self._cache_vulnerability(vuln)

            return vulnerabilities

        except urllib.error.HTTPError as e:
            if e.code == 403:
                logger.warning("NVD rate limit reached. Consider using an API key.")
            else:
                logger.warning(f"NVD query failed: HTTP {e.code}")
            return self._query_local_cache(package, ecosystem)
        except Exception as e:
            logger.exception(f"NVD query failed for {package}")
            return self._query_local_cache(package, ecosystem)

    def lookup(
        self,
        package: str,
        version: str,
        ecosystem: PackageEcosystem,
        sources: list[VulnerabilitySource] | None = None,
    ) -> list[Vulnerability]:
        """
        Look up vulnerabilities for a package.

        Args:
            package: Package name
            version: Package version
            ecosystem: Package ecosystem
            sources: Sources to query (default: OSV)

        Returns:
            List of matching vulnerabilities
        """
        if sources is None:
            sources = [VulnerabilitySource.OSV]

        all_vulns: dict[str, Vulnerability] = {}

        for source in sources:
            vulns = []
            if source == VulnerabilitySource.OSV:
                vulns = self.query_osv(package, version, ecosystem)
            elif source == VulnerabilitySource.NVD:
                vulns = self.query_nvd(package, version, ecosystem)
            elif source == VulnerabilitySource.LOCAL:
                vulns = self._query_local_cache(package, ecosystem)

            # Deduplicate by ID
            for vuln in vulns:
                if vuln.id not in all_vulns:
                    # Check if version is actually affected
                    if vuln.is_version_affected(version):
                        all_vulns[vuln.id] = vuln

        return list(all_vulns.values())

    def add_local_vulnerability(self, vuln: Vulnerability) -> None:
        """Add a vulnerability to the local database."""
        key = f"{vuln.affected_ecosystem.value}:{vuln.affected_package}"
        if key not in self._local_db:
            self._local_db[key] = []
        self._local_db[key].append(vuln)
        self._cache_vulnerability(vuln)

    def load_local_database(self, path: str | Path) -> int:
        """
        Load vulnerabilities from a local JSON file.

        Args:
            path: Path to JSON file with vulnerabilities

        Returns:
            Number of vulnerabilities loaded
        """
        path = Path(path)
        if not path.exists():
            return 0

        try:
            with open(path) as f:
                data = json.load(f)

            count = 0
            for vuln_data in data.get("vulnerabilities", []):
                vuln = self._parse_local_vulnerability(vuln_data)
                if vuln:
                    self.add_local_vulnerability(vuln)
                    count += 1

            return count
        except Exception as e:
            logger.error(f"Failed to load local database: {e}")
            return 0

    def _query_local_cache(
        self,
        package: str,
        ecosystem: PackageEcosystem,
    ) -> list[Vulnerability]:
        """Query the local cache for vulnerabilities."""
        key = f"{ecosystem.value}:{package}"
        return self._local_db.get(key, [])

    def _cache_vulnerability(self, vuln: Vulnerability) -> None:
        """Cache a vulnerability locally."""
        key = f"{vuln.affected_ecosystem.value}:{vuln.affected_package}"
        if key not in self._local_db:
            self._local_db[key] = []

        # Check for duplicates
        existing_ids = {v.id for v in self._local_db[key]}
        if vuln.id not in existing_ids:
            self._local_db[key].append(vuln)

        # Also save to disk cache
        self._save_to_disk_cache(vuln)

    def _save_to_disk_cache(self, vuln: Vulnerability) -> None:
        """Save vulnerability to disk cache."""
        try:
            cache_file = self._cache_dir / f"{vuln.id}.json"
            with open(cache_file, "w") as f:
                json.dump(vuln.to_dict(), f, indent=2, default=str)
        except Exception as e:
            logger.debug(f"Failed to cache vulnerability {vuln.id}: {e}")

    def _parse_osv_vulnerability(
        self,
        data: dict[str, Any],
        ecosystem: PackageEcosystem,
        package: str,
    ) -> Vulnerability | None:
        """Parse OSV vulnerability format."""
        try:
            vuln_id = data.get("id", "")
            if not vuln_id:
                return None

            # Parse severity from CVSS
            severity = VulnerabilitySeverity.UNKNOWN
            cvss_score = None
            cvss_vector = None

            for sev in data.get("severity", []):
                if sev.get("type") == "CVSS_V3":
                    cvss_vector = sev.get("score")
                    # Extract base score from vector if available
                    if cvss_vector and ":" in cvss_vector:
                        # Parse CVSS vector to get score
                        score_match = re.search(r"(\d+\.\d+)", str(data.get("database_specific", {}).get("cvss", "")))
                        if score_match:
                            cvss_score = float(score_match.group(1))
                            severity = self._cvss_to_severity(cvss_score)

            # If no CVSS, try to get severity from database_specific
            if severity == VulnerabilitySeverity.UNKNOWN:
                db_severity = data.get("database_specific", {}).get("severity")
                if db_severity:
                    severity = self._string_to_severity(db_severity)

            # Parse affected versions
            affected_versions = []
            for affected in data.get("affected", []):
                for rng in affected.get("ranges", []):
                    av = AffectedVersion(version_type=rng.get("type", "SEMVER"))
                    for event in rng.get("events", []):
                        if "introduced" in event:
                            av.introduced = event["introduced"]
                        if "fixed" in event:
                            av.fixed = event["fixed"]
                        if "last_affected" in event:
                            av.last_affected = event["last_affected"]
                    affected_versions.append(av)

            # Parse fixed versions
            fixed_versions = []
            for affected in data.get("affected", []):
                for rng in affected.get("ranges", []):
                    for event in rng.get("events", []):
                        if "fixed" in event:
                            fixed_versions.append(event["fixed"])

            # Parse references
            references = []
            for ref in data.get("references", []):
                references.append(VulnerabilityReference(
                    url=ref.get("url", ""),
                    source="osv",
                    tags=ref.get("tags", []),
                ))

            # Parse aliases
            aliases = data.get("aliases", [])

            # Parse dates
            published = None
            modified = None
            withdrawn = None
            if data.get("published"):
                published = datetime.fromisoformat(data["published"].replace("Z", "+00:00"))
            if data.get("modified"):
                modified = datetime.fromisoformat(data["modified"].replace("Z", "+00:00"))
            if data.get("withdrawn"):
                withdrawn = datetime.fromisoformat(data["withdrawn"].replace("Z", "+00:00"))

            return Vulnerability(
                id=vuln_id,
                aliases=aliases,
                summary=data.get("summary", ""),
                description=data.get("details", ""),
                severity=severity,
                cvss_score=cvss_score,
                cvss_vector=cvss_vector,
                source=VulnerabilitySource.OSV,
                affected_ecosystem=ecosystem,
                affected_package=package,
                affected_versions=affected_versions,
                fixed_versions=fixed_versions,
                patch_available=len(fixed_versions) > 0,
                published=published,
                modified=modified,
                withdrawn=withdrawn,
                references=references,
                cwes=data.get("database_specific", {}).get("cwes", []),
                credits=[c.get("name", "") for c in data.get("credits", [])],
                database_specific=data.get("database_specific", {}),
            )
        except Exception as e:
            logger.debug(f"Failed to parse OSV vulnerability: {e}")
            return None

    def _parse_nvd_vulnerability(
        self,
        data: dict[str, Any],
        ecosystem: PackageEcosystem,
        package: str,
        version: str,
    ) -> Vulnerability | None:
        """Parse NVD CVE format."""
        try:
            vuln_id = data.get("id", "")
            if not vuln_id:
                return None

            # Parse descriptions
            descriptions = data.get("descriptions", [])
            description = ""
            for desc in descriptions:
                if desc.get("lang") == "en":
                    description = desc.get("value", "")
                    break

            # Parse CVSS metrics
            severity = VulnerabilitySeverity.UNKNOWN
            cvss_score = None
            cvss_vector = None

            metrics = data.get("metrics", {})
            # Prefer CVSS 3.1 over 3.0 over 2.0
            for metric_type in ["cvssMetricV31", "cvssMetricV30", "cvssMetricV2"]:
                if metric_type in metrics:
                    metric_data = metrics[metric_type][0] if metrics[metric_type] else {}
                    cvss_data = metric_data.get("cvssData", {})
                    cvss_score = cvss_data.get("baseScore")
                    cvss_vector = cvss_data.get("vectorString")
                    if cvss_score:
                        severity = self._cvss_to_severity(cvss_score)
                    break

            # Parse references
            references = []
            for ref in data.get("references", []):
                references.append(VulnerabilityReference(
                    url=ref.get("url", ""),
                    source="nvd",
                    tags=ref.get("tags", []),
                ))

            # Parse CWEs
            cwes = []
            for weakness in data.get("weaknesses", []):
                for desc in weakness.get("description", []):
                    if desc.get("value", "").startswith("CWE-"):
                        cwes.append(desc["value"])

            # Parse dates
            published = None
            modified = None
            if data.get("published"):
                published = datetime.fromisoformat(data["published"].replace("Z", "+00:00"))
            if data.get("lastModified"):
                modified = datetime.fromisoformat(data["lastModified"].replace("Z", "+00:00"))

            return Vulnerability(
                id=vuln_id,
                summary=description[:200] + "..." if len(description) > 200 else description,
                description=description,
                severity=severity,
                cvss_score=cvss_score,
                cvss_vector=cvss_vector,
                source=VulnerabilitySource.NVD,
                affected_ecosystem=ecosystem,
                affected_package=package,
                published=published,
                modified=modified,
                references=references,
                cwes=cwes,
            )
        except Exception as e:
            logger.debug(f"Failed to parse NVD vulnerability: {e}")
            return None

    def _parse_local_vulnerability(
        self,
        data: dict[str, Any],
    ) -> Vulnerability | None:
        """Parse local vulnerability format."""
        try:
            vuln_id = data.get("id", "")
            if not vuln_id:
                return None

            # Parse ecosystem
            affected = data.get("affected", {})
            ecosystem_str = affected.get("ecosystem", "unknown")
            try:
                ecosystem = PackageEcosystem(ecosystem_str)
            except ValueError:
                ecosystem = PackageEcosystem.UNKNOWN

            # Parse severity
            severity_str = data.get("severity", "unknown")
            severity = self._string_to_severity(severity_str)

            # Parse affected versions
            affected_versions = []
            for av_data in affected.get("versions", []):
                av = AffectedVersion(
                    introduced=av_data.get("introduced"),
                    fixed=av_data.get("fixed"),
                    last_affected=av_data.get("last_affected"),
                )
                affected_versions.append(av)

            # Parse references
            references = []
            for ref in data.get("references", []):
                references.append(VulnerabilityReference(
                    url=ref.get("url", ""),
                    source=ref.get("source", "local"),
                    tags=ref.get("tags", []),
                ))

            return Vulnerability(
                id=vuln_id,
                aliases=data.get("aliases", []),
                summary=data.get("summary", ""),
                description=data.get("description", ""),
                severity=severity,
                cvss_score=data.get("cvss_score"),
                cvss_vector=data.get("cvss_vector"),
                source=VulnerabilitySource.LOCAL,
                affected_ecosystem=ecosystem,
                affected_package=affected.get("package", ""),
                affected_versions=affected_versions,
                fixed_versions=data.get("fixed_versions", []),
                patch_available=data.get("patch_available", False),
                references=references,
                cwes=data.get("cwes", []),
            )
        except Exception as e:
            logger.debug(f"Failed to parse local vulnerability: {e}")
            return None

    def _cvss_to_severity(self, score: float) -> VulnerabilitySeverity:
        """Convert CVSS score to severity level."""
        if score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        elif score > 0:
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.NONE

    def _string_to_severity(self, severity: str) -> VulnerabilitySeverity:
        """Convert severity string to enum."""
        severity_lower = severity.lower()
        if severity_lower in ("critical", "crit"):
            return VulnerabilitySeverity.CRITICAL
        elif severity_lower in ("high", "important"):
            return VulnerabilitySeverity.HIGH
        elif severity_lower in ("medium", "moderate", "med"):
            return VulnerabilitySeverity.MEDIUM
        elif severity_lower in ("low", "minor"):
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.UNKNOWN


class VulnerabilityScanner:
    """
    Scanner for detecting vulnerabilities in dependencies.

    Integrates with SBOM parser and vulnerability database to
    identify security issues in software supply chain.
    """

    def __init__(
        self,
        database: VulnerabilityDatabase | None = None,
        sources: list[VulnerabilitySource] | None = None,
    ):
        """
        Initialize the vulnerability scanner.

        Args:
            database: VulnerabilityDatabase instance (creates default if None)
            sources: Vulnerability sources to query (default: OSV)
        """
        self._db = database or VulnerabilityDatabase()
        self._sources = sources or [VulnerabilitySource.OSV]

    def scan_dependency(self, dep: Dependency) -> list[VulnerabilityMatch]:
        """
        Scan a single dependency for vulnerabilities.

        Args:
            dep: Dependency to scan

        Returns:
            List of vulnerability matches
        """
        vulns = self._db.lookup(
            package=dep.name,
            version=dep.version,
            ecosystem=dep.ecosystem,
            sources=self._sources,
        )

        matches = []
        for vuln in vulns:
            match = VulnerabilityMatch(
                dependency=dep,
                vulnerability=vuln,
                match_confidence=1.0,
            )
            matches.append(match)

        return matches

    def scan_dependencies(
        self,
        dependencies: list[Dependency],
    ) -> VulnerabilityScanResult:
        """
        Scan multiple dependencies for vulnerabilities.

        Args:
            dependencies: List of dependencies to scan

        Returns:
            VulnerabilityScanResult with all matches
        """
        import time
        start_time = time.time()

        result = VulnerabilityScanResult(
            total_dependencies=len(dependencies),
            sources_used=[s.value for s in self._sources],
        )

        vulnerable_deps: set[str] = set()

        for dep in dependencies:
            matches = self.scan_dependency(dep)

            for match in matches:
                result.matches.append(match)
                result.total_vulnerabilities += 1

                # Track unique vulnerable dependencies
                dep_key = f"{dep.name}@{dep.version}"
                vulnerable_deps.add(dep_key)

                # Count by severity
                if match.severity == VulnerabilitySeverity.CRITICAL:
                    result.critical_count += 1
                elif match.severity == VulnerabilitySeverity.HIGH:
                    result.high_count += 1
                elif match.severity == VulnerabilitySeverity.MEDIUM:
                    result.medium_count += 1
                elif match.severity == VulnerabilitySeverity.LOW:
                    result.low_count += 1
                else:
                    result.unknown_count += 1

        result.vulnerable_dependencies = len(vulnerable_deps)
        result.scan_duration_ms = int((time.time() - start_time) * 1000)

        return result

    def scan_file(self, file_path: str) -> VulnerabilityScanResult:
        """
        Scan dependencies from a dependency file.

        Args:
            file_path: Path to dependency file

        Returns:
            VulnerabilityScanResult
        """
        from stance.sbom.parser import DependencyParser
        parser = DependencyParser()
        dep_file = parser.parse_file(file_path)
        return self.scan_dependencies(dep_file.dependencies)

    def scan_directory(
        self,
        directory: str,
        recursive: bool = True,
    ) -> VulnerabilityScanResult:
        """
        Scan dependencies from all dependency files in a directory.

        Args:
            directory: Directory to scan
            recursive: Search subdirectories

        Returns:
            VulnerabilityScanResult
        """
        from stance.sbom.parser import DependencyParser
        parser = DependencyParser()
        dep_files = parser.parse_directory(directory, recursive)

        # Collect all unique dependencies
        all_deps: list[Dependency] = []
        seen: set[tuple[str, str, str]] = set()

        for dep_file in dep_files:
            for dep in dep_file.dependencies:
                key = (dep.name, dep.version, dep.ecosystem.value)
                if key not in seen:
                    seen.add(key)
                    all_deps.append(dep)

        return self.scan_dependencies(all_deps)

    def get_summary(self, result: VulnerabilityScanResult) -> str:
        """Generate a human-readable vulnerability scan summary."""
        lines = []
        lines.append("Vulnerability Scan Results")
        lines.append("=" * 40)
        lines.append("")
        lines.append(f"Dependencies Scanned: {result.total_dependencies}")
        lines.append(f"Vulnerable Dependencies: {result.vulnerable_dependencies}")
        lines.append(f"Total Vulnerabilities: {result.total_vulnerabilities}")
        lines.append("")

        if result.has_vulnerabilities:
            lines.append("Severity Breakdown:")
            lines.append(f"  Critical: {result.critical_count}")
            lines.append(f"  High: {result.high_count}")
            lines.append(f"  Medium: {result.medium_count}")
            lines.append(f"  Low: {result.low_count}")
            if result.unknown_count:
                lines.append(f"  Unknown: {result.unknown_count}")
            lines.append("")

            # Show top vulnerabilities
            critical_matches = result.get_critical_matches()
            high_matches = result.get_high_matches()

            if critical_matches:
                lines.append("Critical Vulnerabilities:")
                for match in critical_matches[:5]:
                    lines.append(f"  [{match.vulnerability.id}] {match.dependency.name}@{match.dependency.version}")
                    if match.vulnerability.summary:
                        lines.append(f"    {match.vulnerability.summary[:80]}...")
                    if match.vulnerability.fixed_versions:
                        lines.append(f"    Fixed in: {', '.join(match.vulnerability.fixed_versions[:3])}")
                lines.append("")

            if high_matches:
                lines.append("High Severity Vulnerabilities:")
                for match in high_matches[:5]:
                    lines.append(f"  [{match.vulnerability.id}] {match.dependency.name}@{match.dependency.version}")
                    if match.vulnerability.summary:
                        lines.append(f"    {match.vulnerability.summary[:80]}...")
                lines.append("")
        else:
            lines.append("No vulnerabilities found.")

        lines.append(f"Scan Duration: {result.scan_duration_ms}ms")
        lines.append(f"Sources: {', '.join(result.sources_used)}")

        return "\n".join(lines)


def scan_vulnerabilities(
    path: str,
    recursive: bool = True,
    sources: list[str] | None = None,
) -> VulnerabilityScanResult:
    """
    Convenience function to scan for vulnerabilities.

    Args:
        path: File or directory path
        recursive: Search subdirectories (for directory input)
        sources: Vulnerability sources to use ("osv", "nvd", "local")

    Returns:
        VulnerabilityScanResult
    """
    # Parse sources
    source_list = []
    if sources:
        for s in sources:
            try:
                source_list.append(VulnerabilitySource(s.lower()))
            except ValueError:
                pass
    if not source_list:
        source_list = [VulnerabilitySource.OSV]

    scanner = VulnerabilityScanner(sources=source_list)

    from pathlib import Path
    p = Path(path)

    if p.is_file():
        return scanner.scan_file(str(p))
    elif p.is_dir():
        return scanner.scan_directory(str(p), recursive)
    else:
        raise FileNotFoundError(f"Path not found: {path}")
