"""
Policy data model for Mantissa Stance.

This module defines the Policy class representing security policy definitions
loaded from YAML files, and PolicyCollection for managing groups of policies.
"""

from __future__ import annotations

import json
import re
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Iterator

from stance.models.finding import Severity


class CheckType(Enum):
    """Type of policy check."""

    EXPRESSION = "expression"
    SQL = "sql"


@dataclass(frozen=True)
class ComplianceMapping:
    """
    Maps a policy to a compliance framework control.

    Attributes:
        framework: Framework identifier (e.g., "cis-aws-foundations")
        version: Framework version (e.g., "1.5.0")
        control: Control identifier (e.g., "1.5")
    """

    framework: str
    version: str
    control: str

    def to_dict(self) -> dict[str, str]:
        """Convert to dictionary."""
        return {
            "framework": self.framework,
            "version": self.version,
            "control": self.control,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> ComplianceMapping:
        """Create from dictionary."""
        return cls(
            framework=data.get("framework", ""),
            version=data.get("version", ""),
            control=data.get("control", ""),
        )

    def __str__(self) -> str:
        """Format as string (e.g., 'CIS 1.5.0 - 1.5')."""
        return f"{self.framework} {self.version} - {self.control}"


@dataclass(frozen=True)
class Remediation:
    """
    Remediation guidance for a policy finding.

    Attributes:
        guidance: Human-readable remediation steps
        automation_supported: Whether automated remediation is available
            (always False in Stance - read-only by design)
    """

    guidance: str = ""
    automation_supported: bool = False

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "guidance": self.guidance,
            "automation_supported": self.automation_supported,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Remediation:
        """Create from dictionary."""
        if isinstance(data, str):
            # Handle case where remediation is just a string
            return cls(guidance=data, automation_supported=False)
        return cls(
            guidance=data.get("guidance", ""),
            automation_supported=data.get("automation_supported", False),
        )


@dataclass(frozen=True)
class Check:
    """
    Evaluation logic for a policy.

    Attributes:
        check_type: Type of check (expression or SQL)
        expression: Expression string for expression checks
        query: SQL query for SQL checks
    """

    check_type: CheckType
    expression: str | None = None
    query: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        result: dict[str, Any] = {"type": self.check_type.value}
        if self.expression:
            result["expression"] = self.expression
        if self.query:
            result["query"] = self.query
        return result

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Check:
        """Create from dictionary."""
        check_type_str = data.get("type", "expression")
        check_type = CheckType(check_type_str)
        return cls(
            check_type=check_type,
            expression=data.get("expression"),
            query=data.get("query"),
        )


@dataclass(frozen=True)
class Policy:
    """
    Security policy definition.

    Policies define security checks to evaluate against cloud resources.
    They are loaded from YAML files and evaluated by the policy engine.

    Attributes:
        id: Unique policy identifier (e.g., "aws-iam-001")
        name: Human-readable policy name
        description: Detailed explanation of what the policy checks
        enabled: Whether the policy is enabled for evaluation
        severity: Severity level of findings generated by this policy
        resource_type: AWS resource type this policy applies to
        check: The evaluation logic (expression or SQL)
        compliance: List of compliance framework mappings
        remediation: Remediation guidance
        tags: List of tags for categorization
        references: List of reference URLs
    """

    id: str
    name: str
    description: str
    severity: Severity
    resource_type: str
    check: Check
    enabled: bool = True
    compliance: list[ComplianceMapping] = field(default_factory=list)
    remediation: Remediation = field(default_factory=Remediation)
    tags: list[str] = field(default_factory=list)
    references: list[str] = field(default_factory=list)

    def is_enabled(self) -> bool:
        """
        Check if this policy is enabled.

        Returns:
            True if enabled
        """
        return self.enabled

    def get_compliance_controls(self) -> list[str]:
        """
        Get formatted list of compliance controls.

        Returns:
            List of formatted control strings
        """
        return [str(mapping) for mapping in self.compliance]

    def matches_resource_type(self, resource_type: str) -> bool:
        """
        Check if this policy applies to a resource type.

        Args:
            resource_type: Resource type to check

        Returns:
            True if policy applies to this resource type
        """
        return self.resource_type == resource_type

    def to_dict(self) -> dict[str, Any]:
        """
        Convert policy to dictionary representation.

        Returns:
            Dictionary with all policy fields
        """
        return {
            "id": self.id,
            "name": self.name,
            "description": self.description,
            "enabled": self.enabled,
            "severity": self.severity.value,
            "resource_type": self.resource_type,
            "check": self.check.to_dict(),
            "compliance": [m.to_dict() for m in self.compliance],
            "remediation": self.remediation.to_dict(),
            "tags": self.tags,
            "references": self.references,
        }

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> Policy:
        """
        Create a Policy from a dictionary.

        Args:
            data: Dictionary with policy fields

        Returns:
            New Policy instance
        """
        # Parse severity
        severity_val = data.get("severity", "medium")
        if isinstance(severity_val, str):
            severity = Severity.from_string(severity_val)
        else:
            severity = severity_val

        # Parse check
        check_data = data.get("check", {"type": "expression", "expression": "true"})
        check = Check.from_dict(check_data)

        # Parse compliance mappings
        compliance_data = data.get("compliance", [])
        compliance = [ComplianceMapping.from_dict(c) for c in compliance_data]

        # Parse remediation
        remediation_data = data.get("remediation", {})
        remediation = Remediation.from_dict(remediation_data)

        return cls(
            id=data["id"],
            name=data.get("name", ""),
            description=data.get("description", ""),
            enabled=data.get("enabled", True),
            severity=severity,
            resource_type=data.get("resource_type", ""),
            check=check,
            compliance=compliance,
            remediation=remediation,
            tags=data.get("tags", []),
            references=data.get("references", []),
        )

    @classmethod
    def from_yaml(cls, yaml_content: str) -> Policy:
        """
        Create a Policy from YAML content.

        This uses a simple YAML parser that handles the subset of YAML
        features we need, without requiring the PyYAML dependency.

        Args:
            yaml_content: YAML string containing policy definition

        Returns:
            New Policy instance
        """
        data = _parse_simple_yaml(yaml_content)
        return cls.from_dict(data)


class PolicyCollection:
    """
    A collection of Policy objects with filtering capabilities.

    Provides methods to filter policies by various criteria
    and look up policies by ID.

    Attributes:
        policies: List of Policy objects in this collection
    """

    def __init__(self, policies: list[Policy] | None = None) -> None:
        """
        Initialize collection with optional list of policies.

        Args:
            policies: Initial list of policies (defaults to empty list)
        """
        self._policies: list[Policy] = policies if policies is not None else []

    @property
    def policies(self) -> list[Policy]:
        """Get the list of policies."""
        return self._policies

    def __len__(self) -> int:
        """Return number of policies in collection."""
        return len(self._policies)

    def __iter__(self) -> Iterator[Policy]:
        """Iterate over policies in collection."""
        return iter(self._policies)

    def __getitem__(self, index: int) -> Policy:
        """Get policy by index."""
        return self._policies[index]

    def add(self, policy: Policy) -> None:
        """
        Add a policy to the collection.

        Args:
            policy: Policy to add
        """
        self._policies.append(policy)

    def filter_by_severity(self, severity: Severity) -> PolicyCollection:
        """
        Filter policies by severity.

        Args:
            severity: Severity level to filter by

        Returns:
            New PolicyCollection containing only matching policies
        """
        filtered = [p for p in self._policies if p.severity == severity]
        return PolicyCollection(filtered)

    def filter_by_resource_type(self, resource_type: str) -> PolicyCollection:
        """
        Filter policies by resource type.

        Args:
            resource_type: Resource type to filter by

        Returns:
            New PolicyCollection containing only matching policies
        """
        filtered = [p for p in self._policies if p.resource_type == resource_type]
        return PolicyCollection(filtered)

    def filter_by_framework(self, framework: str) -> PolicyCollection:
        """
        Filter policies by compliance framework.

        Args:
            framework: Framework identifier to filter by

        Returns:
            New PolicyCollection containing only matching policies
        """
        filtered = [
            p
            for p in self._policies
            if any(m.framework == framework for m in p.compliance)
        ]
        return PolicyCollection(filtered)

    def filter_by_tag(self, tag: str) -> PolicyCollection:
        """
        Filter policies by tag.

        Args:
            tag: Tag to filter by

        Returns:
            New PolicyCollection containing only matching policies
        """
        filtered = [p for p in self._policies if tag in p.tags]
        return PolicyCollection(filtered)

    def filter_enabled(self) -> PolicyCollection:
        """
        Filter to only enabled policies.

        Returns:
            New PolicyCollection containing only enabled policies
        """
        filtered = [p for p in self._policies if p.is_enabled()]
        return PolicyCollection(filtered)

    def get_by_id(self, policy_id: str) -> Policy | None:
        """
        Get a policy by its ID.

        Args:
            policy_id: Policy ID to find

        Returns:
            Policy if found, None otherwise
        """
        for policy in self._policies:
            if policy.id == policy_id:
                return policy
        return None

    def to_list(self) -> list[dict[str, Any]]:
        """
        Convert collection to list of dictionaries.

        Returns:
            List of policy dictionaries
        """
        return [policy.to_dict() for policy in self._policies]

    def to_json(self) -> str:
        """
        Convert collection to JSON string.

        Returns:
            JSON string representation
        """
        return json.dumps(self.to_list(), indent=2, default=str)

    @classmethod
    def from_list(cls, data: list[dict[str, Any]]) -> PolicyCollection:
        """
        Create collection from list of dictionaries.

        Args:
            data: List of policy dictionaries

        Returns:
            New PolicyCollection
        """
        policies = [Policy.from_dict(item) for item in data]
        return cls(policies)


def _parse_simple_yaml(content: str) -> dict[str, Any]:
    """
    Parse a simple subset of YAML without external dependencies.

    Supports:
    - Key-value pairs
    - Nested dictionaries
    - Lists (with - prefix)
    - Multiline strings (with | or >)
    - Quoted strings
    - Numbers and booleans

    Args:
        content: YAML content string

    Returns:
        Parsed dictionary
    """
    result: dict[str, Any] = {}
    lines = content.split("\n")
    current_key: str | None = None
    current_indent = 0
    multiline_mode = False
    multiline_content: list[str] = []
    multiline_key: str = ""
    list_key: str | None = None
    list_items: list[Any] = []

    i = 0
    while i < len(lines):
        line = lines[i]
        stripped = line.strip()

        # Skip empty lines and comments
        if not stripped or stripped.startswith("#"):
            if multiline_mode:
                multiline_content.append("")
            i += 1
            continue

        # Calculate indentation
        indent = len(line) - len(line.lstrip())

        # Handle multiline content
        if multiline_mode:
            if indent > current_indent:
                multiline_content.append(line[current_indent + 2 :])
                i += 1
                continue
            else:
                # End of multiline
                result[multiline_key] = "\n".join(multiline_content).strip()
                multiline_mode = False
                multiline_content = []

        # Handle list continuation
        if list_key and stripped.startswith("- "):
            item_content = stripped[2:].strip()
            if ":" in item_content and not item_content.startswith('"'):
                # List item is a dict
                item_dict = _parse_list_item_dict(lines, i)
                list_items.append(item_dict)
                # Skip processed lines
                while i < len(lines) - 1:
                    next_line = lines[i + 1]
                    if not next_line.strip():
                        i += 1
                        continue
                    next_indent = len(next_line) - len(next_line.lstrip())
                    if (
                        next_indent <= indent
                        and not next_line.strip().startswith("- ")
                    ) or (
                        next_indent == indent and next_line.strip().startswith("- ")
                    ):
                        break
                    i += 1
            else:
                list_items.append(_parse_value(item_content))
            i += 1
            continue
        elif list_key:
            # End of list
            result[list_key] = list_items
            list_key = None
            list_items = []

        # Parse key-value pair
        if ":" in stripped:
            colon_pos = stripped.find(":")
            key = stripped[:colon_pos].strip()
            value_part = stripped[colon_pos + 1 :].strip()

            if value_part == "|" or value_part == ">":
                # Multiline string
                multiline_mode = True
                multiline_key = key
                current_indent = indent
            elif value_part == "":
                # Could be nested dict or list
                if i + 1 < len(lines):
                    next_line = lines[i + 1].strip()
                    if next_line.startswith("- "):
                        list_key = key
                        list_items = []
                    else:
                        # Nested dict - parse inline
                        nested = _parse_nested_dict(lines, i + 1, indent + 2)
                        result[key] = nested
                        # Skip to end of nested
                        while i < len(lines) - 1:
                            next_line = lines[i + 1]
                            if not next_line.strip():
                                i += 1
                                continue
                            next_indent = len(next_line) - len(next_line.lstrip())
                            if next_indent <= indent:
                                break
                            i += 1
            else:
                result[key] = _parse_value(value_part)

        i += 1

    # Handle any remaining list
    if list_key:
        result[list_key] = list_items

    # Handle remaining multiline
    if multiline_mode:
        result[multiline_key] = "\n".join(multiline_content).strip()

    return result


def _parse_value(value: str) -> Any:
    """Parse a YAML value string to Python type."""
    value = value.strip()

    # Handle quoted strings
    if (value.startswith('"') and value.endswith('"')) or (
        value.startswith("'") and value.endswith("'")
    ):
        return value[1:-1]

    # Handle booleans
    if value.lower() == "true":
        return True
    if value.lower() == "false":
        return False

    # Handle null
    if value.lower() in ("null", "~", ""):
        return None

    # Handle numbers
    try:
        if "." in value:
            return float(value)
        return int(value)
    except ValueError:
        pass

    return value


def _parse_nested_dict(lines: list[str], start: int, base_indent: int) -> dict[str, Any]:
    """Parse a nested dictionary from lines."""
    result: dict[str, Any] = {}
    i = start

    while i < len(lines):
        line = lines[i]
        stripped = line.strip()

        if not stripped or stripped.startswith("#"):
            i += 1
            continue

        indent = len(line) - len(line.lstrip())
        if indent < base_indent:
            break

        if ":" in stripped:
            colon_pos = stripped.find(":")
            key = stripped[:colon_pos].strip()
            value_part = stripped[colon_pos + 1 :].strip()

            if value_part:
                result[key] = _parse_value(value_part)
            else:
                # Check for nested structure
                if i + 1 < len(lines):
                    next_line = lines[i + 1]
                    if next_line.strip().startswith("- "):
                        # List
                        items = []
                        j = i + 1
                        while j < len(lines):
                            next_stripped = lines[j].strip()
                            if next_stripped.startswith("- "):
                                items.append(_parse_value(next_stripped[2:]))
                                j += 1
                            elif not next_stripped:
                                j += 1
                            else:
                                break
                        result[key] = items
                        i = j - 1

        i += 1

    return result


def _parse_list_item_dict(lines: list[str], start: int) -> dict[str, Any]:
    """Parse a dictionary that is a list item."""
    result: dict[str, Any] = {}
    line = lines[start]
    stripped = line.strip()

    # Get the first key-value from the "- key: value" line
    content = stripped[2:]  # Remove "- "
    if ":" in content:
        colon_pos = content.find(":")
        key = content[:colon_pos].strip()
        value = content[colon_pos + 1 :].strip()
        result[key] = _parse_value(value)

    # Parse any additional keys at the same indent + 2
    base_indent = len(line) - len(line.lstrip()) + 2
    i = start + 1

    while i < len(lines):
        next_line = lines[i]
        if not next_line.strip():
            i += 1
            continue

        next_indent = len(next_line) - len(next_line.lstrip())
        if next_indent < base_indent:
            break
        if next_line.strip().startswith("- "):
            break

        stripped_next = next_line.strip()
        if ":" in stripped_next:
            colon_pos = stripped_next.find(":")
            key = stripped_next[:colon_pos].strip()
            value = stripped_next[colon_pos + 1 :].strip()
            result[key] = _parse_value(value)

        i += 1

    return result
